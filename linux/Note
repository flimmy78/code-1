-- FCSE 快速进程切换。

  通常情况下，两进程虚拟地址有重叠，进程切换涉及虚拟地址和物理地址
  重新映射，以及重建MMU，系统开销比较大。FCSE就为避免系统开销而设计。

  FCSE 位于CPU与MMU之间。它将不同进程的相同虚拟地址转换一遍给MMU，
  这样不同进程的相同虚拟地址就有不同的MVA。

  每个进程都有独立的0x0-0x01ffffff 空间（高7位都为0）。所以当进程访
  问高7位为0的虚拟地址空间时，它访问的是自己的32M进程空间。所以方程


-- uCos-II 进程调度流程

 ^-------^     ^-------^     ^-------^     ^-------^
 | task0 | --> | task1 | --> | task2 | --> | task3 | ..... task_list <------^
  -------       -------       -------       -------                         |
                                                                            |
struct task{                                                                |
	ticks;  ---     { ticks--                             } ## scan --------^
               |----{ if (ticks-- == 0) Change status     } <-----------------^
	status; ---     { if(status == ready) fill Readygrp   }                   |
	 ...                                          ^                           |
}     ^^                                          |                           |
      ||                                           ------------------------^  |
                                                                           |  |
                                                                           |  |
   ^-------^     ^-------^     ^-------^     ^-------^                     |  |
   | time0 | --- | time1 | --- | time2 | --- | time3 | .... time_tick_irq -|--^
    -------       -------       -------       -------                      |
                                                                           |
	os_schedule()  -------- turn to task base on Readygrp  ----------------

---

*  linux 密码破解 john
   unshadow /etc/passwd /etc/shadow > mypasswd
   john mypasswd

*  内核为可运行的进程，根据进程的等级建立不同的链表，提高查找最优进程的速率。

*  1.  fork()子进程 *- 拷贝 -* 父进程的数据段和代码段;vfork()子进程与父进程 *- 共享 -* 数据段
   2.  fork()父子进程的执行次序不确定;vfork 保证子进程先运行，在调用exec
       或exit之前与父进程数据是共享的,在它调用exec或exit 之后父进程才可能被调度运行。
   3.  vfork()保证子进程先运行，在她调用exec 或exit之后父进程才可能被调度运行。如果在
       调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁

*  被抢占的进程并没有被挂起，因为它还处于TASK_RUNNING状态，只不过不再使用CPU。 

*  每个普通进程都有它自己的静态优先级，位于task_struct的static_prio字段，
   调度程序使用静态优先级来估价系统中这个进程与其它普通进程之间调度强度。
   但是，注意，调度程序不是根据静态优先级来决定调度哪个进程的，而是动态优先级.

*  进程静态优先级本质上决定了进程的基本时间片，即进程用完了以前的时间片，系统
   分配给进程的时间片长度。静态优先级越高，其基本时间片就越长。最后的结果是，
   与优先级低的进程相比，通常优先级较高的进程获得更长的CPU时间片

*  原子操作汇编处理数据(加减)确保原子性，使用定义 LOCK_PREFIX

*  大内核锁：确保进程运行在内核态。lock_kernel -- unlock_kernel; 能够被抢占。

*  逻辑地址+ 段基址 = 线性地址 = 物理地址 + 分页 ....

*  页面高速缓存。由于在分页情况下，每次存储器访问都要存取两级页表，这就大大降低了访问速度。
   所以，为了提高速度，在386中设置一个最近存取页面的高速缓存硬件机制，它自动保持32项处理器
   最近使用的页面地址。当进行存储器访问时，先检查要访问的页面是否在高速缓存中，如果在，就不
   必经过两级访问了，如果不在，再进行两级访问。

*  spin lock 确保临界资源在单CPU上。spin lock关闭内核抢占，所以保护的代码不要使用睡眠。
