*** C 内嵌汇编的顺序：从左往右
    __asm__("mov %1, %0":"+r"(output):"r"(input));

	"r" : 用寄存器保存参数
	"i" : 立即数
	"m" : 有效内存地址
	"x" : 只作输入

	 + : 参数可读写
	 无： 参数只写
	 = : 参数只写
	 & : 参数只读


*** PC - 8 ? : PC 的指向不是正在运行的，而是正在取指的地址
        ^-------------------^
 PC - 8 | 取指 | 译指 | 执行 |                  当前PC  ---^
        ----------------------                             |
               ^-------------------^                       |
 PC - 4        | 取指 | 译指 | 执行 |                      |
               ----------------------                      |
                      ^-------------------^                |
 PC                   | 取指 | 译指 | 执行 | <-------------^
                      ----------------------

*** ldmia sp, {r0 - lr}^
    "^": 表示user模式下的寄存器

*** head.S 片段
  ^------------------------------------------------
  |  adr r3 , __lookup_processor_type_data
  |  ldmia r3, {r4 - r6}
  |  sub r3, r3 ,r4      @ get offset = phy - vir
  |  ...
  |
  |  .type __lookup_processor_type_data
  | __lookup_processor_type_data:
  |  .long .
  |  .long  ...
  ^------------------------------------------------
  获取虚拟地址和物理地址之间的差值
  r3 存放的是实际运行的地址--物理地址
  r4 存放的则是链接地址（标号 __lookup_processor_type_data）--虚拟地址

*** .type 说明一个类型
    .type xxx, %object   :  %object 数据类型  %function 函数类型

	.size 占用内存大小
	.size xxx, 8

	.macro 宏；endm 宏结束

*** ld -verbose 查看编译器的默认链接脚本 -T 指定链接脚本

*** 源程序中， .bss段应该在.text 之前。

*** 快速进程切换 -- FCSE
    避免进程切换时重新创建页表...
	4G = 128 个进程空间块（32M），一个进程占用一个
	CPU 发送对虚拟地址VA的请求，FCSE 进行如下转换
	    if VA[32:25] == 0x00

		   MVA = VA|(PID<<25)  # PID = (0 - 127)

	    else

		  MVA = VA

*** TLB 可以看成页表的缓存，用于提高查询页表的效率 ...
    当TLB中不存在需要查找的页表时，会从真正的页表中把页表更新过来 ...

*** str r0, [r5 , #4]!
    "!" 表示 r5 = r5 + 4；即回写的意思 ...

*** MAP 定义一个结构化的内存表首地址，可以简写为 ' ^ '

*** 汇编intel 与 AT&T的区别
    前缀：intel 的寄存器和立即数都没有前缀，AT&T 寄存器前以%,立即数$
	方向：intel 第一个为目的操作数，第二个为源操作数. AT&T则相反。
	内存单元: -----

